# MVVC实现机制

MVCC就是为了实现读-写冲突不加锁，通过维护数据历史版本，从而解决并发访问情况下的读一致性问题

* [一、什么是MVVC](#一什么是mvvc)
* [MVVC实现原理](#二mvvc实现原理)

## 一、什么是MVVC

* MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。
* MySQL 中InnoDB中实现了事务（多版本并发控制MVCC+锁）， 其中通过MVCC解决隔离性问题。
* 具体而言，MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现
* MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读

## 二、什么是MySQL InnoDB下的当前读和快照读

### 当前读

* 它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁
* 像`select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)`这些操作都是一种当前读
  
### 快照读

* 快照读是的是读取最新的快照数据
* 像不加锁的select操作就是快照读，即不加锁的非阻塞读；
* 快照读的前提是：隔离级别不是串行级别，串行级别下的快照读会退化成当前读；
* 之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本
* 说白了MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现

### 当前读，快照读和MVCC的关系

* 准确的说，MVCC多版本并发控制指的是 “维持一个数据的多个版本，使得读写操作没有冲突” 这么一个概念。
* 仅仅是一个理想概念而在MySQL中，实现这么一个MVCC理想概念，我们就需要MySQL提供具体的功能去实现它，而快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。
* 而相对而言，当前读就是悲观锁的具体功能实现
* 要说的再细致一些，快照读本身也是一个抽象概念，再深入研究。

## 三、MVCC能解决什么问题和好处

### 1. 数据库的并发场景

一般的，数据库的并发场景主要有三种，分别是：

* 读-读：不存在任何问题，也不需要并发控制
* 读-写：线程不安全。会造成事务隔离性问题，可能遇到脏堵、幻读、不可重复读
* 写-写：线程不安全。存在更新丢失问题（比如：第一类更新丢失、第二类更新丢失）

### 2、MVVC解决了什么问题

* 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作
* 提高了数据库并发读写的性能 同时还可以解决脏读，幻读，不可重复读等事务隔离问题
* 但不能解决更新丢失问题

### 3、MVVC如何解决更新对视问题

* MVCC + 悲观锁 MVCC解决读写冲突，悲观锁解决写写冲突
* MVCC + 乐观锁 MVCC解决读写冲突，乐观锁解决写写冲突

### 4、MVVC设计原理

* 多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，
* 也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，
* 版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照

## 四、MVVC的具体实现细节

MVCC模型在MySQL中的具体实现则是由 4个隐式字段，undo日志 ，Read View 等去完成的

* 4个隐式字段
* undo日志
* Read View 等去完成的，具体可以看下面的

### 1、四个隐式字段

每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段

* DB_ROW_ID 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引
* DB_TRX_ID 6byte, 最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
* DB_ROLL_PTR 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
* DELETED_BIT 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了

### 2、undo日志

* InnoDB把这些为了回滚而记录的这些东西称之为undo log。这里需要注意的一点是
* 由于查询操作（SELECT）并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo log
* undo log主要分为3种：
  * Insert undo log ：插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。
  * Update undo log：修改一条记录时，至少要把修改这条记录前的旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。
  * Delete undo log：删除一条记录时，至少要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插入到表中就好了。 
    * 删除操作都只是设置一下老记录的DELETED_BIT，并不真正将过时的记录删除。为了节省磁盘空间，InnoDB有专门的purge线程来清理DELETED_BIT为true的记录。
    * 为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;
    * 如果某个记录的DELETED_BIT为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的

### 3、read view

* 什么是Read View，说白了Read View就是事务进行快照读操作的时候生产的读视图(Read View)
* 在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)





==============================分界线 以下未整理====================================


## 二、MVVC实现原理

关于它的实现，要抓住几个关键点：

* 隐式字段
* undo日志
* 版本链
* 快照读&当前读
* Read View。

### 1、版本链

对于InnoDB存储引擎，每一行记录都有两个隐藏列DB_TRX_ID、DB_ROLL_PTR

DB_TRX_ID，事务ID，每次修改时，都会把该事务ID复制给DB_TRX_ID；
DB_ROLL_PTR，回滚指针，指向回滚段的undo日志。

假如有一张user表，表中只有一行记录，当时插入的事务id为80。此时，该条记录的示例图如下：


接下来有两个DB_TRX_ID分别为100、200的事务对这条记录进行update操作，整个过程如下：


由于每次变动都会先把undo日志记录下来，并用DB_ROLL_PTR指向undo日志地址。因此可以认为，对该条记录的修改日志串联起来就形成了一个版本链，版本链的头节点就是当前记录最新的值。如下：


ReadView

对于Read Committed和Repeatable Read隔离级别来说，都需要读取已经提交的事务所修改的记录，也就是说如果版本链中某个版本的修改没有提交，那么该版本的记录时不能被读取的。所以需要确定在Read Committed和Repeatable Read隔离级别下，版本链中哪个版本是能被当前事务读取的。于是就引入了ReadView这个概念来解决这个问题。

Read View就是事务执行快照读时，产生的读视图，相当于某时刻表记录的一个快照，通过这个快照，我们可以获取：


m_ids ：表示在生成 ReadView 时当前系统中活跃的读写事务的事务id 列表。
min_trx_id ：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的 事务id ，也就是 m_ids 中的最小值。
max_trx_id ：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。
creator_trx_id ：表示生成该 ReadView 的事务的 事务id
有了这个 ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

如果被访问版本的 DB_TRX_ID 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
如果被访问版本的 DB_TRX_ID 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。
如果被访问版本的 DB_TRX_ID 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。
如果被访问版本的 DB_TRX_ID 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。
如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。

READ COMMITTED 是每次读取数据前都生成一个ReadView，这样就能保证自己每次都能读到其它事务提交的数据；REPEATABLE READ 是在第一次读取数据时生成一个ReadView，这样就能保证后续读取的结果完全一致。