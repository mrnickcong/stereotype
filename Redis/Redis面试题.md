redis事务是原子性的吗？
redis事务不是原子性的，redis命令是原子性的。

持久化怎么实现的。
Redis实现持久化有两种方式：RDB和AOF。

RDB是将某个时刻的数据作快照然后保存到磁盘，而AOF是将用户执行过的命令按照增量形式保存起来起来。

RDB的优势是可靠性好，但是相邻快照的间隔比较长（比如24小时），比较适合作冷存储；

AOF的优势是持久化间隔小，可以做到秒级。缺点是可靠性不够，适合作热存储。



zset怎么做延迟队列
思路：把当前时间和延迟时间相加，存入Redis中，然后不断轮询，找到到期的，拿到再删除即可。

具体实现可以看：Redis Zset实现延时队列



哪些操作会阻塞redis
redis阻塞的原因有很多。

API或数据结构使用不合理：
两个很大的集合作并集，交集操作，复杂度O(N)，必然阻塞。
慢查询：一次性取出很多key
大量key同时过期也会阻塞
大对象，bigkeys
4. CPU饱和：redis采用单线程，只能使用一个CPU，当CPU使用率过高，就会出现阻塞。

5. 持久化阻塞：

fork阻塞： fork操作发生在rdb和aof重写时,redis主线程调用fork操作产生共享内存的子进程,由子进程完成持久化文件重写工作,若fork操作本身耗时过长,则必会导致主线程阻塞；可执行info stats命令获取到latest_fork_usec指标,表示redis最近一次fork操作耗时,若超过1s,则需要做出优化调整。
aof刷盘阻塞： 当开启aof持久化功能时,文件刷盘的方式一般采用每秒一次,后台线程每秒对aof文件做fsync操作,硬盘压力过大时,fsync操作需要等待,直到写入完成如果主线程发现距离上一次的fsync成功超过2秒,为了数据安全性它会阻塞直到后台线程执行fsync操作完成,这种阻塞行为主要是硬盘压力引起,可查看Redis日志识别出这种情况
6. 网络问题

redis连接拒绝（超过客户端最大连接数）
网络延迟
网卡软中断（一般出现在网络高流量吞吐的场景）
7.内存交换：操作系统在内存不够时，会把部分内存上的页换到磁盘上，导致redis性能急剧下降。

参考资料：redis哪些情况会导致长时间阻塞



redis分布式锁用过吗？说下咋用的，哪些场景需要用
redis的分布式锁采用setnx命令就可以，非常简单。因此很多大型项目选择redis实现分布式锁。基于这个特性，我们就可以用setnx实现加锁的目的：通过setnx加锁，加锁之后其他服务无法加锁，用完之后，再通过delete解锁，深藏功与名。

setnx key value
并且可以设置过期时间：

set key value nx ex seconds

图片版权归@牛牛码特所有
参考资料：Redis分布式锁，你用对了吗？

如何保证缓存-db一致性
读的时候先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。

更新的时候先更新缓存，再更新数据库。不然的话，数据库更新数据是新数据，而缓存还是旧数据，出现数据不一致。

删除的时候，先删缓存，再删数据库。

原则：缓存先操作，数据库后操作。



redis怎么做限流
限流的目的是使单位时间内，访问Redis的请求不至于太多。

利用setnx给key设置过期时间；比如我们需要在10秒内限定20个请求，那么我们在setnx的时候可以设置过期时间10，当请求的setnx数量达到20时候即达到了限流效果。
利用zset，采用的原理也是滑动窗口，我们可以将请求打造成一个zset数组，当每一次请求进来的时候，value保持唯一，可以用UUID生成，而score可以用当前时间戳表示，因为score我们可以用来计算当前时间戳之内有多少的请求数量。而zset数据结构也提供了range方法让我们可以很轻易的获取到2个时间戳内有多少请求
参考资料：Redis 实现限流的三种方式



redis中server和client通信方式？
采用的是RESP，也就是Redis特有的通信协议：

RESP 主要可以序列化以下几种类型：整数，单行回复(简单字符串)，数组，错误信息，多行字符串。Redis 客户端向服务端发送的是一组由执行的命令组成的字符串数组，服务端根据不同的命令回复不同类型的数据，但协议的每部分都是以 "\r\n" (CRLF) 结尾的。另外 RESP 是二进制安全的，不需要处理从一个进程到另一个进程的传输，因为它使用了前缀长度进行传输。

在 RESP 中, 一些数据的类型通过它的第一个字节进行判断：

单行回复：回复的第一个字节是 "+"
错误信息：回复的第一个字节是 "-"
整形数字：回复的第一个字节是 ":"
多行字符串：回复的第一个字节是 "$"
数组：回复的第一个字节是 "*"
优点：非常简单，易懂，人性，这是官方的描述。

参考：Redis Protocol specification - Redis
redis淘汰策略
redis采用了TTL，也就是自动过期机制。但是过期策略有定期删除和惰性过期策略两种，定期删除是对随机抽取一些key中过期的进行删除。惰性过期策略是只有你访问那个key，Redis才会检查是否过期，如果过期就返回空。

因此Redis才有了淘汰策略。淘汰策略有LRU和LFU两种（具体原理比较基础不再讨论）。

参考资料：潇湘夜雨：彻底弄懂Redis的内存淘汰策略